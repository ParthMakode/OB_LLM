 I have successfully recreated autogen from scratch with the new open AI assistance API here is their famous example featuring a chart of YTD meta and Tesla stock prices that was made by my system consisting of just two agents A coding assistant and a user proxy agent but the best part is that this system is much more controllable and customizable which means unlike autogen it is actually Deployable in production I will show you exactly how you can add more agents to the system at the end of this video video so make sure to stay tuned for that let's get started all right open the notebook from the description and let's install the packages which are open Ai and instructor if you haven't heard about instructor this is a library created by Jason Leo that allows us to Define open AI functions as PID dentica this is an absolutely genius way to do this because it is much more convenient than Json and also provides additional features like input and output validation it is the only library that I consistently use in production When developing llm applications and we actually recently had a call with Jason so hopefully we'll release some highlights soon we will also create a small convenience function to print WRA text outputs now let me explain how the assistant API works because it is quite different from the previous chat completions approach in this new API there are threats that represent conversations messages that represent individual messages within the threats and agents that execute the threats to generate new messages I know it can be really confusing at first but the general process is as follows first you have to create an agent then you have to create a threat next you have to add a message to this threat after that you have to create a run for this threat with your threat and agent IDs the big change here is that runs execute asynchronously so you have to continuously check for updates until the run is finished and finally once that's done the Run goes into either the completed or requires action status if it's incompleted it means that you can safely retrieve the threat with the new assistant message while if it's in requires action it means that you have to run your function pass the output back and run the thread again to get the message but to simplify the entire process and make it familiar for all of us who are so used to the previous version of the open AI API I have created a function called get completion that essentially goes through all the steps that I have just described in the loop until the final assistant response is received check out the dog string for more details you might want to copy this function for your own project now let's go ahead and create our first code assistant agent which will be responsible for generating and executing code locally we'll begin with the tools that this agent will utilize defined with the instructor Library the first tool execute Pi file will run an existing python file from disk taking a file name as a parameter in the Run function inside this model will execute the file with Python 3 using the subprocess module and then capture any outputs or errors our second function named file serves to write the file onto the disk for later execution accurate descriptions are crucial here and as you can see by using the instructor Library you can actually Define them directly in the dog strings or the field descriptions associated with each specific parameter inside the model which is extremely convenient we'll also add an additional parameter Chain of Thought this is another ingenious technique introduced by Jason Leo this parameter forces the model to map out each action step by step before proceeding with the function execution this makes our agent more accurate on certain complex tasks without the need to use the Chain of Thought prompt globally as out ofendas which significantly increases the token usage and latency in production next we'll add both of these functions into an array to be used later in our get completion function and create our code assistant using the new beta assistance API for the instructions we state that our code assistant is a top tier programming AI specializing in creating precise Python scripts we will also tell it to ensure that the code is executed before providing a response to the user I decided to design this system by following a typical kubernetes cluster architecture where the user proxy agent is essentially acting as a load balancer that distributes requests to specialized individual agents and Converses with them until the task is fully executed therefore the only tool that the user proxy agent will need is a send message tool to send messages to other specialized agents it has two parameters a recipient and a message the Run call in this function actually calls our previous method get completion with a separate threat for each agent making our system sort of recursive I say sort of because it has only one level of recursion after the main Loop that also uses the get completion function but I actually believe that recursion is the only way to achieve a ji because everything else implies that we have to provide predefined instructions to achieve the given task which is not really general intelligence as I said before I will show you later how to create more agents if this video gets a lot of views I can turn it into an open source project and try to create an agent that creates other agents and tools so please like this video and share it if that's something that you want to see to ensure that our proxy agent has a separate conversation with each of the other agents in this group chat we will store separate threads for each agent in a global object called agents and threats finally we can Define the user proxy agent itself with some instructions that you can check out on your own the most important part here is that the user proxy agent must maintain ongoing communication with the other agents until the task is fully completed the instructions that you pass to the user proxy agent have a huge impact on the behavior of the whole system so definitely make sure to play around with that to launch this system simply create a new thread and start an infinite Loop that prompts for user message gets a completion from the user proxy agent and then prints a response that's it now we are ready to test this system I'll run it with a famous example from autogen for creating a graph of stock prices for meta and Tesla starting with the first question what is today's date as you can see the user proxy agent immediately calls the code agent with a given task although the first time it might not get the recipient name right it immediately corrects itself and then the code execution agent starts to execute the file function the function calls are displayed in red color and the function outputs are displayed in yellow after the code assistant agent writes the code to to the file it executes it and Returns the current date to the user proxy agent which this agent then prints for us below so in this conversation the user proxy agent Converses with the other agents through the send message function basically when it needs to chat with other agents it calls this function with the message which the other agents then receive as the user message after the other agent responds we pass it back as the output of the send message function this allows for a more natural conversation flow where the user proxy agent can and chat with the other agents as much as needed directly from the main chat with the user just by calling this send message function let's try to run the second question compare the year-to-date gain for meta and Tesla now the user proxy agent immediately asks the code assistant to provide the yd gain and then the code assistant proceeds with creating the Chain of Thought prompt and writing the code itself as you can see it gets it on the first try and then Returns the actual numbers using the Y Finance library for the final question let's ask the user proxy to plot the stock price change and save it to the stock price with DPG file after the code assistant executes the necessary code the user proxy confirms that the file has been successfully saved you can verify this by browsing the files on the left as you can see the resulting graph looks exactly like the one generated by autogen however our system actually did it in far less tokens wasted nevertheless there are a few things that you can still improve which I'm going to discuss next first of all this system does not currently support conversations between the the agents that execute the tasks it only supports the conversation between the user proxy with these agents this is not necessarily a bad thing however because this improves the overall steerability of the system and helps to prevent infinite Loops however you can easily adjust this by adding more threats into the agents and threats objects and also allowing other agents to use the send message function second sometimes it feels like the user proxy agent still doesn't fully understand the instructions I've played with the prompt for a little bit but it could certainly use some improvement and third as I said before you could actually make a tool for the user proxy agent that would allow it to create other agents and tools if you actually manage to do this I believe it could lead to exponential growth and a complete Humanity Extinction in the next few months now all jokes aside let's try to add new agents to our system to do so first you have to create the tools that the agent will use using the pantic schemas with the instructor Library as we did before to get started quicker you can simply copy the code for the code assistant agent and replace any tools as needed then add this new agent to the agents and threads objects and create the assistant using the new beta assistant API you can also add out of the box tools like web browsing and code interpreter after creating your new agent add its name to the recipient literal in a send message function and describe what this agent should do in the property description then after running all the CES again run the main Loop and your second task execution assistant should now be live in conclusion the best thing about creating custom agent SWS with the assistant API is that they're actually usable in production unlike other multi-agent systems here you have full control over the creation of new agents and tools you can easily add any guard rails for your specific use case or even Implement any custom logic making this system easily steerable and adaptable for instance I decided to design this example with a single responsibility principle in mind SRP is a common practice for building scalable systems that implies that each component should have only one specific respons ability this allows you to easily add more components or replace existing components as needed so let me know in the comments if you still think that AI will be achieved with one super intelligent model and thousands of tools or rather by scaling thousands of smaller agents together and lastly for those who need help building their own custom agent SWS feel free to reach out to me thank you for watching and don't forget to subscribe